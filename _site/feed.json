{
    "version": "https://jsonfeed.org/version/1",
    "title": "Technical Blog",
    "home_page_url": "http://localhost:4000/",
    "feed_url": "http://localhost:4000/feed.json",
    "description": "Posts Relating to Full Stack Web Development",
    "icon": "http://localhost:4000/apple-touch-icon.png",
    "favicon": "http://localhost:4000/favicon.ico",
    "expired": false,
    
    "author": "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}",
    
"items": [
    
        {
            "id": "http://localhost:4000/2020/08/10/kontra-js",
            "title": "There's still a fire! Let's make a game!",
            "summary": "A first look at the Kontra.js micro-library",
            "content_text": "A first look at the Kontra.js javascript gaming micro-librayIn the giant world of software development, there is truly an awe-inspiring array of options for solving any problem, tackling any project, or building any app. Languages, stacks, design patterns, frameworks, the list goes on! Personally, I’ve found a certain kindred spirit amongst those that abide by the philosophy of “build it first, build it fast, figure out the rest later”. Even though Rails is a deep and thorough framework, the ability to get a rails app scaffolded and running in 20 minutes was revolutionary for web development.Continuing on in the spirit of the Camping ruby micro-framework, I’ve taken a first look at Kontra.js, a javascript gaming micro-framework. Created for a javascript Game-Jam event where developers were limited to a miniscule file-size, Kontra clocks in at a whopping 14kb. While often used to prototype games, or to get up and running quickly, Kontra’s first commercial release was the Jackbox Games’ “Murder Party”, topping out at over a million units sold. Let’s take a look!Importing the initialize functipon from the Kontra library allows the game to run and build the game canvas.import { init } from 'kontra';let { canvas, context } = init();Now we can import the Sprite and Gameloop methods to easily build out a simple sprite and event loop.import { init, Sprite, GameLoop } from 'kontra';let { canvas } = init();let sprite = Sprite({  x: 100,        // starting x,y position of the sprite  y: 80,  color: 'red',  // fill color of the sprite rectangle  width: 20,     // width and height of the sprite rectangle  height: 40,  dx: 2          // move the sprite 2px to the right every frame});let loop = GameLoop({  // create the main game loop  update: function() { // update the game state    sprite.update();    // wrap the sprites position when it reaches    // the edge of the screen    if (sprite.x &gt; canvas.width) {      sprite.x = -sprite.width;    }  },  render: function() { // render the game state    sprite.render();  }});loop.start();    // start the gameLook at that! We’ve got some stuff moving around the screen. That’s practically a game! Handling user-input is just as intuitive, using the Kontra “keyPressed” method. Imagine your game allowed the player to pilot a ship.let ship = kontra.Sprite({  x: 300,  y: 300,  width: 6,  // we'll use this later for collision detection  rotation: 0,  // 0 degrees is to the right  render() {    this.context.save();        // transform the origin and rotate around it     // using the ships rotation    this.context.translate(this.x, this.y);    this.context.rotate(degreesToRadians(this.rotation));        // draw a right facing triangle    this.context.beginPath();    this.context.moveTo(-3, -5);    this.context.lineTo(12, 0);    this.context.lineTo(-3, 5);    this.context.closePath();    this.context.stroke();    this.context.restore();  },  update() {    // rotate the ship left or right    if (kontra.keyPressed('left')) {      this.rotation += -4    }    else if (kontra.keyPressed('right')) {      this.rotation += 4    }        // move the ship forward in the direction it's facing    const cos = Math.cos(degreesToRadians(this.rotation));    const sin = Math.sin(degreesToRadians(this.rotation));        if (kontra.keyPressed('up')) {        this.ddx = cos * 0.05;        this.ddy = sin * 0.05;    }    this.advance();  }});Pretty exciting stuff, right? The Kontra.js site lists off dozens of games built with the library that are available to play, along with their github repositories. Starting small never felt so big!",
            "content_html": "<h2 id=\"a-first-look-at-the-kontrajs-javascript-gaming-micro-libray\">A first look at the Kontra.js javascript gaming micro-libray</h2><p>In the giant world of software development, there is truly an awe-inspiring array of options for solving any problem, tackling any project, or building any app. Languages, stacks, design patterns, frameworks, the list goes on! Personally, I’ve found a certain <em>kindred spirit</em> amongst those that abide by the philosophy of “build it first, build it fast, figure out the rest later”. Even though Rails is a deep and thorough framework, the ability to get a rails app scaffolded and running in 20 minutes was revolutionary for web development.</p><p><img src=\"https://efangelist.files.wordpress.com/2014/08/ifyoubuildittheywillcome.png\" alt=\"get it built!\" /></p><p>Continuing on in the spirit of the Camping ruby micro-framework, I’ve taken a first look at Kontra.js, a javascript gaming micro-framework. Created for a javascript Game-Jam event where developers were limited to a miniscule file-size, Kontra clocks in at a whopping 14kb. While often used to prototype games, or to get up and running quickly, Kontra’s first commercial release was the Jackbox Games’ “Murder Party”, topping out at over a million units sold. Let’s take a look!</p><p>Importing the initialize functipon from the Kontra library allows the game to run and build the game canvas.</p><pre><code>import { init } from 'kontra';let { canvas, context } = init();</code></pre><p>Now we can import the Sprite and Gameloop methods to easily build out a simple sprite and event loop.</p><pre><code>import { init, Sprite, GameLoop } from 'kontra';let { canvas } = init();let sprite = Sprite({  x: 100,        // starting x,y position of the sprite  y: 80,  color: 'red',  // fill color of the sprite rectangle  width: 20,     // width and height of the sprite rectangle  height: 40,  dx: 2          // move the sprite 2px to the right every frame});let loop = GameLoop({  // create the main game loop  update: function() { // update the game state    sprite.update();    // wrap the sprites position when it reaches    // the edge of the screen    if (sprite.x &gt; canvas.width) {      sprite.x = -sprite.width;    }  },  render: function() { // render the game state    sprite.render();  }});loop.start();    // start the game</code></pre><p>Look at that! We’ve got some stuff moving around the screen. That’s practically a game! Handling user-input is just as intuitive, using the Kontra “keyPressed” method. Imagine your game allowed the player to pilot a ship.</p><pre><code>let ship = kontra.Sprite({  x: 300,  y: 300,  width: 6,  // we'll use this later for collision detection  rotation: 0,  // 0 degrees is to the right  render() {    this.context.save();        // transform the origin and rotate around it     // using the ships rotation    this.context.translate(this.x, this.y);    this.context.rotate(degreesToRadians(this.rotation));        // draw a right facing triangle    this.context.beginPath();    this.context.moveTo(-3, -5);    this.context.lineTo(12, 0);    this.context.lineTo(-3, 5);    this.context.closePath();    this.context.stroke();    this.context.restore();  },  update() {    // rotate the ship left or right    if (kontra.keyPressed('left')) {      this.rotation += -4    }    else if (kontra.keyPressed('right')) {      this.rotation += 4    }        // move the ship forward in the direction it's facing    const cos = Math.cos(degreesToRadians(this.rotation));    const sin = Math.sin(degreesToRadians(this.rotation));        if (kontra.keyPressed('up')) {        this.ddx = cos * 0.05;        this.ddy = sin * 0.05;    }    this.advance();  }});</code></pre><p><img src=\"https://miro.medium.com/max/1400/1*s755uqld64G8wfS9XpGzjA.png\" alt=\"now were zoomin\" /></p><p>Pretty exciting stuff, right? The Kontra.js site lists off dozens of games built with the library that are available to play, along with their github repositories. Starting small never felt so big!</p><p><img src=\"https://i.imgur.com/fkEiwLW.png\" alt=\"games!\" /></p>",
            "url": "http://localhost:4000/2020/08/10/kontra-js",
            
            
            
            
            
            "date_published": "2020-08-10T00:00:00-05:00",
            "date_modified": "2020-08-10T00:00:00-05:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        },
    
        {
            "id": "http://localhost:4000/2020/07/19/lets-go-camping",
            "title": "Everything's on Fire - Let's go camping!",
            "summary": "first steps into the Camping Ruby Micro Framework",
            "content_text": "A visual introduction to Ruby frameworksAs we begin moving away from the terminal and into full-fledged web development, we start to examine and work within some Ruby frameworks. First, we touched on Sinatra. Sinatra is a regular cat - not too smart, not too dumb, knows how to do some stuff, but you’re gonna have to teach it to do most anything useful. I like regular cats. They’re great to play with, and can even provide all sorts of teachable moments! As a first pet…i mean framework, Sinatra/regular cat is a solid jumping off point.Then there’s RailsRails is a lion - big, powerful, intimidating, and definitely not a candidate for your first pet. But, as we maybe (kind of?) learned from the Netflix series Tiger King, those that can harness the power of big cats can accomplish truly great (?) things. Github itself was built on a Rails backend! The first time you run rails new Project in your console and a few hundred files, folders, dependencies, and sub-libraries are generated in a flash is truly an awe-inspiring experience. Learning to navigate the file structures that rails builds for you, and slowly incorporating the various helper methods that rails provide is immensley gratifying. Heck, the first time I ran rails g scaffold Student name age:integer.... and watched as it created all the requisite MVC files, classes, db migration, and so on that I had previously spent hours learning to build out in a basic Sinatra app, I really began to understand all this talk of rails magic.But ultimate, rails is an undertaking. It’s extensive, layered, and has taken (me at least) hours upon hours of trial and error, googling, and headshaking to make progress in. I can imagine a scenario where I have an idea for a simple app, but maybe don’t want to do all the legwork involved with getting a rails project off the ground.Enter CampingCamping is a ruby micro-framework created by, as far as I can tell, a few weirdos who have more or less removed their presence from the internet. Camping is tiny - the entire framework source code is less than 4 kb. What’s more, Camping’s core ethos is that your entire app can/should be contained in a single ruby document. Your MVC all exist simultaneously in one place. While you’re free to build out other pages and require_relative them, Camping excels at being an agile launch pad for ideas.With the camping gem installed (it’s recommended you install the camping omnibus, as it includes markaby - more on that in a bit), All you need to do to get rolling is drop Camping.goes :AppName at the top of your ruby document. Running $ camping appname.rb in console will fire up a live server, and your project is up and running! Start by building out some viewsmodule SandwichLad::Views    def layout        html do            title { &#39;Sandwich Lad&#39; }            body {                 h1 &#39;Welcome to Sandwich Lad&#39;                h2 &quot;it&#39;s #{Time.now}, time to talk-a sandwich&quot;                  self &lt;&lt; yield                         }            footer {                h4 &quot;COPYRIGHT IN PERPETUITY&quot;            }        end    end    def landing        body :id =&gt; :frontpage do            h3 &#39;its my sandwich world&#39;, :class =&gt; :main            ul do                    div do a &#39;add sandwich&#39;, :href =&gt; &#39;/sandwiches/new&#39; end                 div do a &#39;see sandwiches&#39;, :href =&gt; &#39;/sandwiches&#39; end             end         end    endendand then associate those views with some controllers via routesmodule SandwichLad::Controllers    class Index &lt; R &#39;/&#39;        def get            render :landing        end    end    class NewSandwich &lt; R &#39;/sandwiches/new&#39;        def get            render :new_sandwich            end    end    class IndexSandwich &lt; R &#39;/sandwiches&#39;        def get            render :sandwiches         end    end endNotice all that inline html? That’s markaby! Markaby (Markup as Ruby) is a relatively straightforward alternative to erb with lousy documentation, but solid usability! We can even link to an external css stylesheet to style our app. Now we’re up to a whopping 2 files!Finally, we can build out a model and initial table migration.module SandwichLad::Models    class Sandwich &lt; Base    end    class BasicFields &lt; ActiveRecord::Migration[4.2]        def self.up          create_table Sandwich.create_sandwiches do |t|            t.string :name            t.text   :bread            t.text   :cheese            t.text   :proteins            t.text   :condiments            # This gives us created_at and updated_at            t.timestamps          end         end        def self.down            drop_table Sandwich.create_sandwiches        end    endenddef SandwichLad.create    SandwichLad::Models.create_schemaendOur Basicfield class inherits from Active Record, and our schema gets created once the app is instanciated via the SandwichLad.create method. At this point we’ve written out a very basic MVC pattern in under 100 lines of code, in a single ruby document. Neat! And while Camping is surely not an alternative for larger, more in-depth projects, it’s comforting to know there’s an option to speedily map out app ideas. As the saying goes, the right tool for the job, the right cat for the app. ",
            "content_html": "<h2 id=\"a-visual-introduction-to-ruby-frameworks\">A visual introduction to Ruby frameworks</h2><p>As we begin moving away from the terminal and into full-fledged web development, we start to examine and work within some Ruby frameworks. First, we touched on Sinatra. <img src=\"https://images.unsplash.com/photo-1514888286974-6c03e2ca1dba?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=2827&amp;q=80\" alt=\"a regular cat\" />Sinatra is a regular cat - not too smart, not too dumb, knows how to do some stuff, but you’re gonna have to teach it to do most anything useful. I like regular cats. They’re great to play with, and can even provide all sorts of teachable moments! As a first pet…i mean framework, Sinatra/regular cat is a solid jumping off point.</p><h3 id=\"then-theres-rails\">Then there’s Rails</h3><p><img src=\"https://images.unsplash.com/photo-1471123327422-e370dc57a3da?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=2422&amp;q=80\" alt=\"a big lion\" />Rails is a lion - big, powerful, intimidating, and definitely not a candidate for your first pet. But, as we maybe (kind of?) learned from the Netflix series Tiger King, those that can harness the power of big cats can accomplish truly great (?) things. Github itself was built on a Rails backend! The first time you run <code>rails new Project</code> in your console and a few hundred files, folders, dependencies, and sub-libraries are generated in a flash is truly an awe-inspiring experience. Learning to navigate the file structures that rails builds for you, and slowly incorporating the various helper methods that rails provide is immensley gratifying. Heck, the first time I ran <code>rails g scaffold Student name age:integer....</code> and watched as it created all the requisite MVC files, classes, db migration, and so on that I had previously spent <em>hours</em> learning to build out in a basic Sinatra app, I really began to understand all this talk of <strong>rails magic</strong>.</p><p>But ultimate, rails is an undertaking. It’s extensive, layered, and has taken (me at least) hours upon hours of trial and error, googling, and headshaking to make progress in. I can imagine a scenario where I have an idea for a simple app, but maybe don’t want to do all the legwork involved with getting a rails project off the ground.</p><h3 id=\"enter-camping\">Enter Camping</h3><p><img src=\"https://images.unsplash.com/photo-1542736143-29a8432162bc?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=3150&amp;q=80\" alt=\"kitten\" />Camping is a ruby micro-framework created by, as far as I can tell, a few weirdos who have more or less removed their presence from the internet. Camping is tiny - the entire framework source code is less than <strong>4 kb</strong>. What’s more, Camping’s core ethos is that your entire app can/should be contained in a single ruby document. Your MVC all exist simultaneously in one place. While you’re free to build out other pages and <code>require_relative</code> them, Camping excels at being an agile launch pad for ideas.</p><p>With the camping gem installed (it’s recommended you install the camping omnibus, as it includes markaby - more on that in a bit), All you need to do to get rolling is drop <code>Camping.goes :AppName</code> at the top of your ruby document. Running <code>$ camping appname.rb</code> in console will fire up a live server, and your project is up and running! Start by building out some views</p><figure class=\"highlight\"><pre><code class=\"language-ruby\" data-lang=\"ruby\">module SandwichLad::Views    def layout        html do            title { &#39;Sandwich Lad&#39; }            body {                 h1 &#39;Welcome to Sandwich Lad&#39;                h2 &quot;it&#39;s #{Time.now}, time to talk-a sandwich&quot;                  self &lt;&lt; yield                         }            footer {                h4 &quot;COPYRIGHT IN PERPETUITY&quot;            }        end    end    def landing        body :id =&gt; :frontpage do            h3 &#39;its my sandwich world&#39;, :class =&gt; :main            ul do                    div do a &#39;add sandwich&#39;, :href =&gt; &#39;/sandwiches/new&#39; end                 div do a &#39;see sandwiches&#39;, :href =&gt; &#39;/sandwiches&#39; end             end         end    endend</code></pre></figure><p>and then associate those views with some controllers via routes</p><figure class=\"highlight\"><pre><code class=\"language-ruby\" data-lang=\"ruby\">module SandwichLad::Controllers    class Index &lt; R &#39;/&#39;        def get            render :landing        end    end    class NewSandwich &lt; R &#39;/sandwiches/new&#39;        def get            render :new_sandwich            end    end    class IndexSandwich &lt; R &#39;/sandwiches&#39;        def get            render :sandwiches         end    end end</code></pre></figure><p>Notice all that inline html? That’s markaby! Markaby (Markup as Ruby) is a relatively straightforward alternative to erb with lousy documentation, but solid usability! We can even link to an external css stylesheet to style our app. Now we’re up to a whopping 2 files!</p><p>Finally, we can build out a model and initial table migration.</p><figure class=\"highlight\"><pre><code class=\"language-ruby\" data-lang=\"ruby\">module SandwichLad::Models    class Sandwich &lt; Base    end    class BasicFields &lt; ActiveRecord::Migration[4.2]        def self.up          create_table Sandwich.create_sandwiches do |t|            t.string :name            t.text   :bread            t.text   :cheese            t.text   :proteins            t.text   :condiments            # This gives us created_at and updated_at            t.timestamps          end         end        def self.down            drop_table Sandwich.create_sandwiches        end    endenddef SandwichLad.create    SandwichLad::Models.create_schemaend</code></pre></figure><p>Our Basicfield class inherits from Active Record, and our schema gets created once the app is instanciated via the <code>SandwichLad.create</code> method. At this point we’ve written out a very basic MVC pattern in under 100 lines of code, in a single ruby document. Neat! And while Camping is surely not an alternative for larger, more in-depth projects, it’s comforting to know there’s an option to speedily map out app ideas. As the saying goes, the right tool for the job, the right cat for the app. <img src=\"https://www.northumbriacommunity.org/wp-content/uploads/2013/05/kitten-lion-mirror.jpg\" alt=\"mirror cat\" /></p>",
            "url": "http://localhost:4000/2020/07/19/lets-go-camping",
            
            
            
            
            
            "date_published": "2020-07-19T00:00:00-05:00",
            "date_modified": "2020-07-19T00:00:00-05:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        },
    
        {
            "id": "http://localhost:4000/2020/07/09/flatiron-mod1-project-soccer-buddy",
            "title": "SOCCER BUDDY 64",
            "summary": "A Flatiron Mod 1 CLI application",
            "content_text": "SOCCER BUDDY 64SOCCER BUDDY 64 is a CLI application built in Ruby using Sinatra ActiveRecord to create our model structure. Our database is seeded from a CSV file of the 2019-2020 English Premiere League soccer schedule. The app allows users to  Create/Login to their own unique account, persisted in our database  Search for league matches by team or stadium  Add matches to their favorites list  View, sort, and manipulate their favorites listDuring the build process we experienced a handful of challenges. Some of the major obstacles included  Parsing data from our original seed file, an XLS spreadsheet  Setting up checks to validate user input and not throw errors  Building out an intuitive and attractive UISpreadsheet Hell - Seeding our databaseBecause of the current international pandemic most professional soccer leagues are shuttered, or operating on a much reduced capacity. This means that seeding our database from a live API would yield limited results. Instead, a quick search for soccer database returned a fully fleshed out .XLS document file. Because .XLS is an outdated filetype (having been replaced with XLSX), there are only a couple of Ruby gems available that were able to parse the file. we ulitmately settled on the Spreadsheet gem, which worked correctly in a test environment. Unforunately, we faced a number of bugs when attempting to implement it in our working environment, with various errors targeting ActiveRecord and the gem itself. After a few hours of failed troubleshooting, we realized we could simply convert the spreadsheet file from XLS to CSV and use Ruby’s built-in CSV library. This solutoin was up and running almost immediately! The only caveat here was the CSV parser was incorrectly interpreting the spreadseet “Date” and “Time” data, instead spitting out static and incorrect data. We decided to scrap implementing time/date functionality and instead focus on what worked.data = CSV.read(&quot;EPL_Fixturelist_1920.csv&quot;)data.each do |row|    Match.create(home_team: row[1], away_team: row[5], location: row[6], date: row[2])endComputers are dumb, and so are weAnother hurdle we faced was attempting to account for user error when at all possible. The first solution was to turn to TTY::Prompt, a ruby gem that enabled us to write user-selectable responses. Instead of asking for user responses, we were able to implement a menu of selectable options.def add_to_favorites   answer = $prompt.select(&quot;Would you like to add a match to your favorites?&quot;.colorize(:color =&gt; :black, :background =&gt; :light_green), &quot;YES&quot;, &quot;NO&quot;)        case        when answer == &quot;YES&quot;            puts &quot;Please select a match by ID&quot;            print &quot;&gt; &quot;            number = gets.chomp             system(&#39;clear&#39;)            Favorite.create(user_id: $user.id, match_id: number)            favoriteMatchesAre = TTY::Box.info(&quot;your favorites are now:&quot;)            print favoriteMatchesAre             $user.reload            $user.matches.each { |match| ap &quot;#{match.home_team} play #{match.away_team} at #{match.location}.&quot; }                        display_options()            user_input()        when answer == &quot;NO&quot;            system(&#39;clear&#39;)            display_options()            user_input()        endendThe other major validation checkpoint was upon login - We needed a way to check our database of users against the input to see if that user exists. If the user exists, than the current user should be assigned to that user ID. If not, the app should kick back an error and prompt the user for new input. The solution we developed is sloppy, but functional.case        when answer == &quot;NEW USER&quot;            puts &quot;Whats your name?&quot;.colorize(:color =&gt; :black, :background =&gt; :light_green)            print &quot;&gt; &quot;            name = gets.chomp            $user = User.create(name: name)            welcomeUser = TTY::Box.success(&quot;Your user ID is #{$user.id}, please remember this number!&quot;)            print welcomeUser        when answer == &quot;EXISTING USER&quot;            puts &quot;Please enter your user ID&quot;            print &quot;&gt; &quot;            answer_id = gets.chomp               allIds = []            User.all.each { |user| allIds &lt;&lt; user.id }            if allIds.include?(answer_id.to_i)                    $user = User.all.find{ |user| user.id == answer_id.to_i }                        welcomeExistingUser = TTY::Box.success(&quot;Welcome back #{$user.name}&quot;)                    print welcomeExistingUser                else puts TTY::Box.error(&quot;USER ID NOT FOUND SORRY FRIEND&quot;)                                        welcome()            end        endIf attempting to access an existing account, the user submits an ID #. An empty array is created, and all existing User.id info in the database is shoveled into the array. Then the array is checked to see if it includes the input data (converted to an integer). If it exists, the user is tied to the existing account.And it looks nice, too!Once the app was functionally built out, we focused our attention on the user experience. This mainly took the form of contextual colorization, intuitive menu structures, a thorough README, and a demonstration video.Stray thoughtsThis Mod 1 project was an excellent crash course on code collaboration, time management, troubleshooting, googling, and all the other foundational skills that SWE careers are built on. I’d say overall we’d give the experience an A, A-. Solid project. Good job.",
            "content_html": "<h3 id=\"soccer-buddy-64\">SOCCER BUDDY 64</h3><p><img src=\"https://raw.githubusercontent.com/matthewlawrenceklein/ruby-project-guidelines-chi01-seng-ft-062220/Jacob/Images/N64%20SUPPER%20SOCCER%20BUDDY%2064.jpg\" alt=\"Soccer Buddy\" /></p><p>SOCCER BUDDY 64 is a CLI application built in Ruby using Sinatra ActiveRecord to create our model structure. Our database is seeded from a CSV file of the 2019-2020 English Premiere League soccer schedule. The app allows users to</p><ul>  <li>Create/Login to their own unique account, persisted in our database</li>  <li>Search for league matches by team or stadium</li>  <li>Add matches to their favorites list</li>  <li>View, sort, and manipulate their favorites list</li></ul><p>During the build process we experienced a handful of challenges. Some of the major obstacles included</p><ul>  <li>Parsing data from our original seed file, an XLS spreadsheet</li>  <li>Setting up checks to validate user input and not throw errors</li>  <li>Building out an intuitive and attractive UI</li></ul><h2 id=\"spreadsheet-hell---seeding-our-database\">Spreadsheet Hell - Seeding our database</h2><p>Because of the current international pandemic most professional soccer leagues are shuttered, or operating on a much reduced capacity. This means that seeding our database from a live API would yield limited results. Instead, a quick search for <em>soccer database</em> returned a fully fleshed out .XLS document file. Because .XLS is an outdated filetype (having been replaced with XLSX), there are only a couple of Ruby gems available that were able to parse the file. we ulitmately settled on the Spreadsheet gem, which worked correctly in a test environment. Unforunately, we faced a number of bugs when attempting to implement it in our working environment, with various errors targeting ActiveRecord and the gem itself. After a few hours of failed troubleshooting, we realized we could simply convert the spreadsheet file from XLS to CSV and use Ruby’s built-in CSV library. This solutoin was up and running almost immediately! The only caveat here was the CSV parser was incorrectly interpreting the spreadseet “Date” and “Time” data, instead spitting out static and incorrect data. We decided to scrap implementing time/date functionality and instead focus on what worked.</p><figure class=\"highlight\"><pre><code class=\"language-ruby\" data-lang=\"ruby\">data = CSV.read(&quot;EPL_Fixturelist_1920.csv&quot;)data.each do |row|    Match.create(home_team: row[1], away_team: row[5], location: row[6], date: row[2])end</code></pre></figure><h2 id=\"computers-are-dumb-and-so-are-we\">Computers are dumb, and so are we</h2><p>Another hurdle we faced was attempting to account for user error when at all possible. The first solution was to turn to TTY::Prompt, a ruby gem that enabled us to write user-selectable responses. Instead of asking for user responses, we were able to implement a menu of selectable options.</p><figure class=\"highlight\"><pre><code class=\"language-ruby\" data-lang=\"ruby\">def add_to_favorites   answer = $prompt.select(&quot;Would you like to add a match to your favorites?&quot;.colorize(:color =&gt; :black, :background =&gt; :light_green), &quot;YES&quot;, &quot;NO&quot;)        case        when answer == &quot;YES&quot;            puts &quot;Please select a match by ID&quot;            print &quot;&gt; &quot;            number = gets.chomp             system(&#39;clear&#39;)            Favorite.create(user_id: $user.id, match_id: number)            favoriteMatchesAre = TTY::Box.info(&quot;your favorites are now:&quot;)            print favoriteMatchesAre             $user.reload            $user.matches.each { |match| ap &quot;#{match.home_team} play #{match.away_team} at #{match.location}.&quot; }                        display_options()            user_input()        when answer == &quot;NO&quot;            system(&#39;clear&#39;)            display_options()            user_input()        endend</code></pre></figure><p>The other major validation checkpoint was upon login - We needed a way to check our database of users against the input to see if that user exists. If the user exists, than the current user should be assigned to that user ID. If not, the app should kick back an error and prompt the user for new input. The solution we developed is sloppy, but functional.</p><figure class=\"highlight\"><pre><code class=\"language-ruby\" data-lang=\"ruby\">case        when answer == &quot;NEW USER&quot;            puts &quot;Whats your name?&quot;.colorize(:color =&gt; :black, :background =&gt; :light_green)            print &quot;&gt; &quot;            name = gets.chomp            $user = User.create(name: name)            welcomeUser = TTY::Box.success(&quot;Your user ID is #{$user.id}, please remember this number!&quot;)            print welcomeUser        when answer == &quot;EXISTING USER&quot;            puts &quot;Please enter your user ID&quot;            print &quot;&gt; &quot;            answer_id = gets.chomp               allIds = []            User.all.each { |user| allIds &lt;&lt; user.id }            if allIds.include?(answer_id.to_i)                    $user = User.all.find{ |user| user.id == answer_id.to_i }                        welcomeExistingUser = TTY::Box.success(&quot;Welcome back #{$user.name}&quot;)                    print welcomeExistingUser                else puts TTY::Box.error(&quot;USER ID NOT FOUND SORRY FRIEND&quot;)                                        welcome()            end        end</code></pre></figure><p>If attempting to access an existing account, the user submits an ID #. An empty array is created, and all existing User.id info in the database is shoveled into the array. Then the array is checked to see if it includes the input data (converted to an integer). If it exists, the user is tied to the existing account.</p><h2 id=\"and-it-looks-nice-too\">And it looks nice, too!</h2><p>Once the app was functionally built out, we focused our attention on the user experience. This mainly took the form of contextual colorization, intuitive menu structures, a thorough README, and a demonstration video.</p><h2 id=\"stray-thoughts\">Stray thoughts</h2><p>This Mod 1 project was an excellent crash course on code collaboration, time management, troubleshooting, googling, and all the other foundational skills that SWE careers are built on. I’d say overall we’d give the experience an A, A-. Solid project. Good job.</p><p><img src=\"https://i.imgur.com/rJCPOVV.png\" alt=\"agile development\" /></p>",
            "url": "http://localhost:4000/2020/07/09/flatiron-mod1-project-soccer-buddy",
            
            
            
            
            
            "date_published": "2020-07-09T00:00:00-05:00",
            "date_modified": "2020-07-09T00:00:00-05:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        },
    
        {
            "id": "http://localhost:4000/2020/06/25/chompr-proof-of-concept",
            "title": "chompr Pt. 1 -  Proof of concept",
            "summary": "Pt. 1 - Proof of concept",
            "content_text": "A Starting PointI don’t think I’m alone in saying that my first foray into software development began when I had an idea for an app that I wanted bad enoughthat when I couldn’t find it, I decided to try and learn how to make it myself. A few months later I’ve learned enough to know that I knowprecious little, but I finally feel like I’m on a path where I can see the app at the end of the tunnel.I’m going to use these blog posts as an opportunity to chronicle the process of developing an app alongside developing a skillset. Let’s go!chompr - Or, “IDK, what do you feel like?”I’ve spent way too many nights laying on the couch with a friend or partner doing the back-and-forth dance of “what are you in the mood to eat”. It’s a vicious cycle of hunger, indecision, and ultimately, the resignation of eventually landing on a choice that no one’s particularly excited for. Literally any alternative would be prefarable: a giant plinko board, prize wheel, or even… an app. Ideally an app that can help its users choose a meal option  easily  quickly  intuitively  fairly, with respect to each chooserAt this point, I’ve put together a wish list of features/functionality that I’d like to pursue, with varying degrees of complexity. Of course, it’s all pretty complex for me right now, but I’m attemping to tackle it in small chunks. For functionality, I’m hoping to build out an app that:  accepts a geographic location (user-input zipcode? cellular location data? Google web location data?)  allows for either delivery or take-out  accepts a number of choosers, with names for each (I think the process starts to break down with 5+ choosers)  provides the choosers with a randomized set of eight food categories (ie Thai, Korean, BBQ, Pub Fare)  randomly selects a chooser to select a category to eliminate, within a time limit (30 second?)  Once choosers have eliminated all but one option, the app instantiates a search for nearby restaurants in that category.I’ve got some stretch goals too, including user auth and API integration (grubhub? uber eats?). And any mobile development is firmly in the stretch category.Humble Beginnings - Let’s write some codeI’ve got a couple of big ol’ lists of stuff I don’t know how to do yet up there, but I can start by building some base functionality. First, let’s figure out a way to randomly generate eight food categories from a much larger “database” of catagories.def create_choices    options = %w[Thai Sushi Japanese Southern Korean Greek Armenian Italian Pizza Burgers     Sandwiches BBQ Mexican American Fast-Food Diner Chinese Pub-Fare]        mixed = options.shuffle        $choice_set = []    (0...8).map { |i| $choice_set.push(mixed[i]) }endCool, so now we’ve got the ability to grab a new and randomized choice set every time. Now we should try and grab the number of chompers, and allow for naming each of them. Again, we’ll probably want to keep the max chompers to 4.def get_users        print &quot;&gt; &quot;        $users = $stdin.gets.chomp         case         when $users.to_i &lt;= 4            puts &quot;~&quot; * 15            puts &quot;super&quot;        when $users.to_i &gt; 4            puts &quot;~&quot; * 15            puts &quot;too many folx&quot;            get_users()        else            puts &quot;~&quot; * 15            puts &quot;invalid input&quot;            get_users()        end        puts &quot;~&quot; * 15    endAnd let’s get names for each chomperdef name_users        $user_array = []        i = 0            while i &lt; $users.to_i do            print &quot;user #{i + 1} name &gt; &quot;            $user_array[i] = $stdin.gets.chomp            i += 1        end``        puts &quot;super, we&#39;ve got&quot;        puts &quot;~&quot; * 15        puts $user_array        puts &quot;~&quot; * 15    endFinally, let’s layout the logic for each elimination round. We want to  randomly select a chomper to make a selection  show the chomper the current food options  take input for the option they’d like to eliminate  remove the option from the options set  repeat until one option remainsHere’s what I’ve got so fardef elimination_round            while $choice_set.length &gt; 1            shuffled_users = $user_array.shuffle()            puts &quot;#{shuffled_users[0]}, you&#39;ve been selected to eliminate an option&quot;            puts &quot;what would you like to eliminate?&quot;            print &quot;&gt; &quot;            eliminate = $stdin.gets.chomp            $choice_set.each do |name|                if name == eliminate                    $choice_set.delete(name)                end            end            puts &quot;your options are now&quot;            puts &quot;~&quot; * 15            puts $choice_set            puts &quot;~&quot; * 15        end    endExcellent! Now we’re making progress!Coming Up NextWe’ve not got the basic logic functioning, and we’re set to take user input from the command line. My next step is going to be packaging this functionality into a CLI ruby gem, and shipping a first completed product - so to speak. C’yall in a few weeks!",
            "content_html": "<h3 id=\"a-starting-point\">A Starting Point</h3><p>I don’t think I’m alone in saying that my first foray into software development began when I had an idea for an app that I wanted bad enoughthat when I couldn’t find it, I decided to try and learn how to make it myself. A few months later I’ve learned enough to know that I knowprecious little, but I finally feel like I’m on a path where I can see the <em>app</em> at the end of the tunnel.</p><p>I’m going to use these blog posts as an opportunity to chronicle the process of developing an app <em>alongside</em> developing a skillset. Let’s go!</p><h3 id=\"chompr---or-idk-what-do-you-feel-like\">chompr - Or, “IDK, what do you feel like?”</h3><p>I’ve spent <strong>way</strong> too many nights laying on the couch with a friend or partner doing the back-and-forth dance of “what are you in the mood to eat”. It’s a vicious cycle of hunger, indecision, and ultimately, the resignation of eventually landing on a choice that no one’s particularly excited for. Literally any alternative would be prefarable: a giant plinko board, prize wheel, or even… an <strong>app</strong>. Ideally an app that can help its users choose a meal option</p><p><img src=\"https://external-preview.redd.it/zC3dcSZFa0BOSk-AbVIqN3vwy7lIKwKnlzs5DGpAz5E.jpg?width=1024&amp;auto=webp&amp;s=2cb4f9c634b5a431978867eeaa765887f4b4bab8\" alt=\"spin the choice\" class=\"img-responsive\" /></p><ul>  <li>easily</li>  <li>quickly</li>  <li>intuitively</li>  <li>fairly, with respect to each chooser</li></ul><p><img src=\"https://rciemecdn.imgix.net/API/Blog/tapas_800px.jpg\" alt=\"lots of food\" class=\"img-responsive\" /></p><p>At this point, I’ve put together a <em>wish list</em> of features/functionality that I’d like to pursue, with varying degrees of complexity. Of course, it’s all pretty complex for me right now, but I’m attemping to tackle it in small chunks. For functionality, I’m hoping to build out an app that:</p><ul>  <li>accepts a geographic location (user-input zipcode? cellular location data? Google web location data?)</li>  <li>allows for either delivery or take-out</li>  <li>accepts a number of choosers, with names for each (I think the process starts to break down with 5+ choosers)</li>  <li>provides the choosers with a randomized set of eight food categories (ie Thai, Korean, BBQ, Pub Fare)</li>  <li>randomly selects a chooser to select a category to eliminate, within a time limit (30 second?)</li>  <li>Once choosers have eliminated all but one option, the app instantiates a search for nearby restaurants in that category.</li></ul><p>I’ve got some stretch goals too, including user auth and API integration (grubhub? uber eats?). And any mobile development is firmly in the stretch category.</p><h3 id=\"humble-beginnings---lets-write-some-code\">Humble Beginnings - Let’s write some code</h3><p>I’ve got a couple of big ol’ lists of stuff I don’t know how to do yet up there, but I can start by building some base functionality. First, let’s figure out a way to randomly generate eight food categories from a much larger “database” of catagories.</p><figure class=\"highlight\"><pre><code class=\"language-ruby\" data-lang=\"ruby\">def create_choices    options = %w[Thai Sushi Japanese Southern Korean Greek Armenian Italian Pizza Burgers     Sandwiches BBQ Mexican American Fast-Food Diner Chinese Pub-Fare]        mixed = options.shuffle        $choice_set = []    (0...8).map { |i| $choice_set.push(mixed[i]) }end</code></pre></figure><p>Cool, so now we’ve got the ability to grab a new and randomized choice set every time. Now we should try and grab the number of chompers, and allow for naming each of them. Again, we’ll probably want to keep the max chompers to 4.</p><figure class=\"highlight\"><pre><code class=\"language-ruby\" data-lang=\"ruby\">def get_users        print &quot;&gt; &quot;        $users = $stdin.gets.chomp         case         when $users.to_i &lt;= 4            puts &quot;~&quot; * 15            puts &quot;super&quot;        when $users.to_i &gt; 4            puts &quot;~&quot; * 15            puts &quot;too many folx&quot;            get_users()        else            puts &quot;~&quot; * 15            puts &quot;invalid input&quot;            get_users()        end        puts &quot;~&quot; * 15    end</code></pre></figure><p>And let’s get names for each chomper</p><figure class=\"highlight\"><pre><code class=\"language-ruby\" data-lang=\"ruby\">def name_users        $user_array = []        i = 0            while i &lt; $users.to_i do            print &quot;user #{i + 1} name &gt; &quot;            $user_array[i] = $stdin.gets.chomp            i += 1        end``        puts &quot;super, we&#39;ve got&quot;        puts &quot;~&quot; * 15        puts $user_array        puts &quot;~&quot; * 15    end</code></pre></figure><p>Finally, let’s layout the logic for each elimination round. We want to</p><ul>  <li>randomly select a chomper to make a selection</li>  <li>show the chomper the current food options</li>  <li>take input for the option they’d like to eliminate</li>  <li>remove the option from the options set</li>  <li>repeat until one option remains</li></ul><p>Here’s what I’ve got so far</p><figure class=\"highlight\"><pre><code class=\"language-ruby\" data-lang=\"ruby\">def elimination_round            while $choice_set.length &gt; 1            shuffled_users = $user_array.shuffle()            puts &quot;#{shuffled_users[0]}, you&#39;ve been selected to eliminate an option&quot;            puts &quot;what would you like to eliminate?&quot;            print &quot;&gt; &quot;            eliminate = $stdin.gets.chomp            $choice_set.each do |name|                if name == eliminate                    $choice_set.delete(name)                end            end            puts &quot;your options are now&quot;            puts &quot;~&quot; * 15            puts $choice_set            puts &quot;~&quot; * 15        end    end</code></pre></figure><p>Excellent! Now we’re making progress!<img src=\"https://media.giphy.com/media/40F4fLvOkInEk/giphy.gif\" alt=\"happy racoon\" /></p><h3 id=\"coming-up-next\">Coming Up Next</h3><p>We’ve not got the basic logic functioning, and we’re set to take user input from the command line. My next step is going to be packaging this functionality into a CLI ruby gem, and <em>shipping</em> a first <em>completed</em> product - so to speak. C’yall in a few weeks!</p>",
            "url": "http://localhost:4000/2020/06/25/chompr-proof-of-concept",
            
            
            
            
            
            "date_published": "2020-06-25T00:00:00-05:00",
            "date_modified": "2020-06-25T00:00:00-05:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        }
    
    ]
}