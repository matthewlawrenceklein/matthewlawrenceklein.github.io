<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Technical Blog</title>
 <link href="http://localhost:4000/atom.xml" rel="self"/>
 <link href="http://localhost:4000/"/>
 <updated>2020-07-09T18:10:36-05:00</updated>
 <id>http://localhost:4000</id>
 <author>
   <name></name>
   <email></email>
 </author>

 
 <entry>
   <title>SOCCER BUDDY 64</title>
   <link href="http://localhost:4000/2020/07/09/flatiron-mod1-project-soccer-buddy"/>
   <updated>2020-07-09T00:00:00-05:00</updated>
   <id>http://localhost:4000/2020/07/09/Flatiron-Mod1-Project-Soccer-Buddy</id>
   <content type="html">&lt;h3 id=&quot;soccer-buddy-64&quot;&gt;SOCCER BUDDY 64&lt;/h3&gt;

&lt;p&gt;SOCCER BUDDY 64 is a CLI application built in Ruby using Sinatra ActiveRecord to create our model structure. Our database is seeded from a CSV file of the 2019-2020 English Premiere League soccer schedule. The app allows users to&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Create/Login to their own unique account, persisted in our database&lt;/li&gt;
  &lt;li&gt;Search for league matches by team or stadium&lt;/li&gt;
  &lt;li&gt;Add matches to their favorites list&lt;/li&gt;
  &lt;li&gt;View, sort, and manipulate their favorites list&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;During the build process we experienced a handful of challenges. Some of the major obstacles included&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Parsing data from our original seed file, an XLS spreadsheet&lt;/li&gt;
  &lt;li&gt;Setting up checks to validate user input and not throw errors&lt;/li&gt;
  &lt;li&gt;Building out an intuitive and attractive UI&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;spreadsheet-hell---seeding-our-database&quot;&gt;Spreadsheet Hell - Seeding our database&lt;/h2&gt;

&lt;p&gt;Because of the current international pandemic most professional soccer leagues are shuttered, or operating on a much reduced capacity. This means that seeding our database from a live API would yield limited results. Instead, a quick search for &lt;em&gt;soccer database&lt;/em&gt; returned a fully fleshed out .XLS document file. Because .XLS is an outdated filetype (having been replaced with XLSX), there are only a couple of Ruby gems available that were able to parse the file. we ulitmately settled on the Spreadsheet gem, which worked correctly in a test environment. Unforunately, we faced a number of bugs when attempting to implement it in our working environment, with various errors targeting ActiveRecord and the gem itself. After a few hours of failed troubleshooting, we realized we could simply convert the spreadsheet file from XLS to CSV and use Ruby’s built-in CSV library. This solutoin was up and running almost immediately! The only caveat here was the CSV parser was incorrectly interpreting the spreadseet “Date” and “Time” data, instead spitting out static and incorrect data. We decided to scrap implementing time/date functionality and instead focus on what worked.&lt;/p&gt;

&lt;h2 id=&quot;computers-are-dumb-and-so-are-we&quot;&gt;Computers are dumb, and so are we&lt;/h2&gt;

&lt;p&gt;Another hurdle we faced was attempting to account for user error when at all possible. The first solution was to turn to TTY::Prompt, a ruby gem that enabled us to write user-selectable responses. Instead of asking for user responses, we were able to implement a menu of selectable options.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;def add_to_favorites
   answer = $prompt.select(&amp;quot;Would you like to add a match to your favorites?&amp;quot;.colorize(:color =&amp;gt; :black, :background =&amp;gt; :light_green), &amp;quot;YES&amp;quot;, &amp;quot;NO&amp;quot;)
        case
        when answer == &amp;quot;YES&amp;quot;
            puts &amp;quot;Please select a match by ID&amp;quot;
            print &amp;quot;&amp;gt; &amp;quot;
            number = gets.chomp 
            system(&amp;#39;clear&amp;#39;)
            Favorite.create(user_id: $user.id, match_id: number)
            favoriteMatchesAre = TTY::Box.info(&amp;quot;your favorites are now:&amp;quot;)
            print favoriteMatchesAre 
            $user.reload
            $user.matches.each { |match| ap &amp;quot;#{match.home_team} play #{match.away_team} at #{match.location}.&amp;quot; }
            
            display_options()
            user_input()
        when answer == &amp;quot;NO&amp;quot;
            system(&amp;#39;clear&amp;#39;)
            display_options()
            user_input()
        end
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The other major validation checkpoint was upon login - We needed a way to check our database of users against the input to see if that user exists. If the user exists, than the current user should be assigned to that user ID. If not, the app should kick back an error and prompt the user for new input. The solution we developed is sloppy, but functional.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;case
        when answer == &amp;quot;NEW USER&amp;quot;
            puts &amp;quot;Whats your name?&amp;quot;.colorize(:color =&amp;gt; :black, :background =&amp;gt; :light_green)
            print &amp;quot;&amp;gt; &amp;quot;
            name = gets.chomp
            $user = User.create(name: name)
            welcomeUser = TTY::Box.success(&amp;quot;Your user ID is #{$user.id}, please remember this number!&amp;quot;)
            print welcomeUser
        when answer == &amp;quot;EXISTING USER&amp;quot;
            puts &amp;quot;Please enter your user ID&amp;quot;
            print &amp;quot;&amp;gt; &amp;quot;
            answer_id = gets.chomp   
            allIds = []
            User.all.each { |user| allIds &amp;lt;&amp;lt; user.id }

            if allIds.include?(answer_id.to_i)
                    $user = User.all.find{ |user| user.id == answer_id.to_i }    
                    welcomeExistingUser = TTY::Box.success(&amp;quot;Welcome back #{$user.name}&amp;quot;)
                    print welcomeExistingUser
                else puts TTY::Box.error(&amp;quot;USER ID NOT FOUND SORRY FRIEND&amp;quot;)
                    
                    welcome()
            end
        end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If attempting to access an existing account, the user submits an ID #. An empty array is created, and all existing User.id info in the database is shoveled into the array. Then the array is checked to see if it includes the input data (converted to an integer). If it exists, the user is tied to the existing account.&lt;/p&gt;

&lt;h2 id=&quot;and-it-looks-nice-too&quot;&gt;And it looks nice, too!&lt;/h2&gt;

&lt;p&gt;Once the app was functionally built out, we focused our attention on the user experience. This mainly took the form of contextual colorization, intuitive menu structures, a thorough README, and a demonstration video.&lt;/p&gt;

&lt;h2 id=&quot;stray-thoughts&quot;&gt;Stray thoughts&lt;/h2&gt;

&lt;p&gt;This Mod 1 project was an excellent crash course on code collaboration, time management, troubleshooting, googling, and all the other foundational skills that SWE careers are built on. I’d say overall we’d give the experience an A, A-. Solid project. Good job.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/rJCPOVV.png&quot; alt=&quot;agile development&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>chompr Pt. 1 -  Proof of concept</title>
   <link href="http://localhost:4000/2020/06/25/chompr-proof-of-concept"/>
   <updated>2020-06-25T00:00:00-05:00</updated>
   <id>http://localhost:4000/2020/06/25/chompr-proof-of-concept</id>
   <content type="html">&lt;h3 id=&quot;a-starting-point&quot;&gt;A Starting Point&lt;/h3&gt;

&lt;p&gt;I don’t think I’m alone in saying that my first foray into software development began when I had an idea for an app that I wanted bad enough
that when I couldn’t find it, I decided to try and learn how to make it myself. A few months later I’ve learned enough to know that I know
precious little, but I finally feel like I’m on a path where I can see the &lt;em&gt;app&lt;/em&gt; at the end of the tunnel.&lt;/p&gt;

&lt;p&gt;I’m going to use these blog posts as an opportunity to chronicle the process of developing an app &lt;em&gt;alongside&lt;/em&gt; developing a skillset. Let’s go!&lt;/p&gt;

&lt;h3 id=&quot;chompr---or-idk-what-do-you-feel-like&quot;&gt;chompr - Or, “IDK, what do you feel like?”&lt;/h3&gt;

&lt;p&gt;I’ve spent &lt;strong&gt;way&lt;/strong&gt; too many nights laying on the couch with a friend or partner doing the back-and-forth dance of “what are you in the mood to eat”. It’s a vicious cycle of hunger, indecision, and ultimately, the resignation of eventually landing on a choice that no one’s particularly excited for. Literally any alternative would be prefarable: a giant plinko board, prize wheel, or even… an &lt;strong&gt;app&lt;/strong&gt;. Ideally an app that can help its users choose a meal option&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://external-preview.redd.it/zC3dcSZFa0BOSk-AbVIqN3vwy7lIKwKnlzs5DGpAz5E.jpg?width=1024&amp;amp;auto=webp&amp;amp;s=2cb4f9c634b5a431978867eeaa765887f4b4bab8&quot; alt=&quot;spin the choice&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;easily&lt;/li&gt;
  &lt;li&gt;quickly&lt;/li&gt;
  &lt;li&gt;intuitively&lt;/li&gt;
  &lt;li&gt;fairly, with respect to each chooser&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://rciemecdn.imgix.net/API/Blog/tapas_800px.jpg&quot; alt=&quot;lots of food&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;At this point, I’ve put together a &lt;em&gt;wish list&lt;/em&gt; of features/functionality that I’d like to pursue, with varying degrees of complexity. Of course, it’s all pretty complex for me right now, but I’m attemping to tackle it in small chunks. For functionality, I’m hoping to build out an app that:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;accepts a geographic location (user-input zipcode? cellular location data? Google web location data?)&lt;/li&gt;
  &lt;li&gt;allows for either delivery or take-out&lt;/li&gt;
  &lt;li&gt;accepts a number of choosers, with names for each (I think the process starts to break down with 5+ choosers)&lt;/li&gt;
  &lt;li&gt;provides the choosers with a randomized set of eight food categories (ie Thai, Korean, BBQ, Pub Fare)&lt;/li&gt;
  &lt;li&gt;randomly selects a chooser to select a category to eliminate, within a time limit (30 second?)&lt;/li&gt;
  &lt;li&gt;Once choosers have eliminated all but one option, the app instantiates a search for nearby restaurants in that category.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I’ve got some stretch goals too, including user auth and API integration (grubhub? uber eats?). And any mobile development is firmly in the stretch category.&lt;/p&gt;

&lt;h3 id=&quot;humble-beginnings---lets-write-some-code&quot;&gt;Humble Beginnings - Let’s write some code&lt;/h3&gt;

&lt;p&gt;I’ve got a couple of big ol’ lists of stuff I don’t know how to do yet up there, but I can start by building some base functionality. First, let’s figure out a way to randomly generate eight food categories from a much larger “database” of catagories.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;def create_choices
    options = %w[Thai Sushi Japanese Southern Korean Greek Armenian Italian Pizza Burgers 
    Sandwiches BBQ Mexican American Fast-Food Diner Chinese Pub-Fare]
    
    mixed = options.shuffle
    
    $choice_set = []

    (0...8).map { |i| $choice_set.push(mixed[i]) }
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Cool, so now we’ve got the ability to grab a new and randomized choice set every time. Now we should try and grab the number of chompers, and allow for naming each of them. Again, we’ll probably want to keep the max chompers to 4.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;def get_users
        print &amp;quot;&amp;gt; &amp;quot;
        $users = $stdin.gets.chomp 

        case 
        when $users.to_i &amp;lt;= 4
            puts &amp;quot;~&amp;quot; * 15
            puts &amp;quot;super&amp;quot;
        when $users.to_i &amp;gt; 4
            puts &amp;quot;~&amp;quot; * 15
            puts &amp;quot;too many folx&amp;quot;
            get_users()
        else
            puts &amp;quot;~&amp;quot; * 15
            puts &amp;quot;invalid input&amp;quot;
            get_users()
        end
        puts &amp;quot;~&amp;quot; * 15
    end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;And let’s get names for each chomper&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;def name_users

        $user_array = []
        i = 0
    
        while i &amp;lt; $users.to_i do
            print &amp;quot;user #{i + 1} name &amp;gt; &amp;quot;
            $user_array[i] = $stdin.gets.chomp
            i += 1
        end

``
        puts &amp;quot;super, we&amp;#39;ve got&amp;quot;
        puts &amp;quot;~&amp;quot; * 15
        puts $user_array
        puts &amp;quot;~&amp;quot; * 15
    end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Finally, let’s layout the logic for each elimination round. We want to&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;randomly select a chomper to make a selection&lt;/li&gt;
  &lt;li&gt;show the chomper the current food options&lt;/li&gt;
  &lt;li&gt;take input for the option they’d like to eliminate&lt;/li&gt;
  &lt;li&gt;remove the option from the options set&lt;/li&gt;
  &lt;li&gt;repeat until one option remains&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here’s what I’ve got so far&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;def elimination_round
    
        while $choice_set.length &amp;gt; 1
            shuffled_users = $user_array.shuffle()
            puts &amp;quot;#{shuffled_users[0]}, you&amp;#39;ve been selected to eliminate an option&amp;quot;
            puts &amp;quot;what would you like to eliminate?&amp;quot;
            print &amp;quot;&amp;gt; &amp;quot;
            eliminate = $stdin.gets.chomp

            $choice_set.each do |name|
                if name == eliminate
                    $choice_set.delete(name)
                end
            end

            puts &amp;quot;your options are now&amp;quot;
            puts &amp;quot;~&amp;quot; * 15
            puts $choice_set
            puts &amp;quot;~&amp;quot; * 15
        end
    end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Excellent! Now we’re making progress!
&lt;img src=&quot;https://media.giphy.com/media/40F4fLvOkInEk/giphy.gif&quot; alt=&quot;happy racoon&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;coming-up-next&quot;&gt;Coming Up Next&lt;/h3&gt;

&lt;p&gt;We’ve not got the basic logic functioning, and we’re set to take user input from the command line. My next step is going to be packaging this functionality into a 
CLI ruby gem, and &lt;em&gt;shipping&lt;/em&gt; a first &lt;em&gt;completed&lt;/em&gt; product - so to speak. C’yall in a few weeks!&lt;/p&gt;
</content>
 </entry>
 

</feed>
